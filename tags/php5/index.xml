<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Php5 on Geeky Ramblings</title>
    <link>/tags/php5/</link>
    <description>Recent content in Php5 on Geeky Ramblings</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 20 Jul 2012 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/php5/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>L’import RSS natif d’eZ Publish avec support de la balise enclosure</title>
      <link>/post/import-rss-natif-ez-publish-support-balise-enclosure/</link>
      <pubDate>Fri, 20 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>/post/import-rss-natif-ez-publish-support-balise-enclosure/</guid>
      <description>

&lt;p&gt;&lt;img class=&#34;thumbnail pull-left&#34; src=&#34;/images/post/ezpublish_media_import_rss-150x150.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;le-besoin:9c6f926ca04ed334e17e208e483449a0&#34;&gt;Le besoin&lt;/h3&gt;

&lt;p&gt;eZ publish offre la possibilité sans écrire une seule ligne de code, d’importer des contenus d’un flux RSS, sous forme de contenus eZpublish. Mais cette fonctionnalité native ne permet pas d’importer les média inclus dans la balise &lt;code&gt;&amp;lt;enclosure&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Je vais donc vous montrer comme vous permettre de récupérer ce media (image ou autre fichier tel que pdf, doc ou flv) et de l’insérer de manière transparente dans vos contenus eZ Publish.
Cette fonctionnalité est un peu codé en dur dans eZ Publish et n’est pas extensible proprement. Je vais vous la manière &lt;em&gt;Quick and dirty&lt;/em&gt; pour arriver à vos fin. A vous ensuite de choisir si vous voulez passer du temp à faire cela proprement.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;enclosure url=&amp;quot;http://www.example.com/images/voiture.jpg&amp;quot; length=&amp;quot;&amp;quot; type=&amp;quot;image/jpeg&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;implémentation-quick-and-dirty:9c6f926ca04ed334e17e208e483449a0&#34;&gt;Implémentation quick and dirty&lt;/h3&gt;

&lt;p&gt;Voici les fichiers qui seront impacter par nos modifications. Ce sont des fichiers du noyau eZPublish&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;La fonction &lt;code&gt;setObjectAttributeValue()&lt;/code&gt; dans le fichier &lt;code&gt;cronjobs/rssimport.php&lt;/code&gt; (script php apellé par crond pour aller récupérer les nouveaux items des flux RSS configurés en Back Office)&lt;/li&gt;
&lt;li&gt;La methode &lt;code&gt;rssFieldDefinition()&lt;/code&gt; dans le fichier &lt;code&gt;kernel/classes/ezrssimport.php&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La fonction &lt;code&gt;setObjectAttributeValue()&lt;/code&gt; permet de traiter la récupération des différents types d’attributs (ligne de texte, bloc xml), c’est donc ici que nous allons naturellement ajouter le traitement de notre attribut ezimage (cela fonctionne aussi avec ezfile). Nous allons rajouter le &lt;code&gt;case ‘ezimage’&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function setObjectAttributeValue( $objectAttribute, $value )
{
    //…
    switch( $dataType )
    {
        //…
        case ‘ezimage’:
        {
            $file = pathinfo($value);
            $image = eZHTTPTool::getDataByURL( $value );
            if($image !== false)
            {
                $fp = fopen(‘/tmp/’.$file[‘basename’],‘wb’);
                fwrite($fp, $image, strlen($image));
                fclose($fp);
                $objectAttribute-&amp;gt;fromString( ‘/tmp/’.$file[‘basename’] );
            }
        } break;
        //..
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Après s’être occupé d’apprendre à &lt;strong&gt;eZ Publish&lt;/strong&gt; comment traiter les ezimage. Nous allons maintenant ajouter &lt;code&gt;Item – Enclosure – Url&lt;/code&gt; dans le &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; (voir image plus haut). Occupons nous de la méthode &lt;code&gt;rssFieldDefinition()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case ’2.0′:
case ’0.91′:
case ’0.92′:
{
  return array( ‘item’ =&amp;gt; array( ‘elements’ =&amp;gt; array( ‘title’,
                                                      ‘link’,
                                                      ‘description’,
                                                      ‘author’,
                                                      ‘category’,
                                                      ‘comments’,
                                                      ‘guid’,
                                                      ‘pubDate’,
                                                      ‘enclosure’ =&amp;gt; array( ‘attributes’ =&amp;gt; array( ‘url’ ) ) ) ),
                ‘channel’ =&amp;gt; array( ‘elements’ =&amp;gt; array( ‘title’,
                                                         ‘link’,
                                                         ‘description’,
                                                         ‘copyright’,
                                                         ‘managingEditor’,
                                                         ‘webMaster’,
                                                         ‘pubDate’,
                                                         ‘lastBuildDate’,
                                                         ‘category’,
                                                         ‘generator’,
                                                         ‘docs’,
                                                         ‘cloud’,
                                                         ‘ttl’ ) ) );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;implémentation-plus-propre:9c6f926ca04ed334e17e208e483449a0&#34;&gt;Implémentation plus propre&lt;/h3&gt;

&lt;p&gt;Au lieu de modifier le cron &lt;code&gt;rssimport.php&lt;/code&gt; vous pouvez le copier dans votre extension y apporter les modifications pour le ezimage. Et appeler ce dernier au lieu du &lt;code&gt;rssimport.php&lt;/code&gt; par défaut d’eZ Publish.
La méthode &lt;code&gt;rssFieldDefinition()&lt;/code&gt; est utilisé dans une autre méthode de la même classe, on remarque la présence d’un hook qui permet d’étendre sa définition a partir des classes présentes dans nos extensions custom.
Voici le hook qui est dans la méthode &lt;code&gt;fieldMap()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$fieldDefinition = eZRSSImport::rssFieldDefinition();

$ini = eZINI::instance();
foreach( $ini-&amp;gt;variable( ‘RSSSettings’, ‘ActiveExtensions’ ) as $activeExtension )
{
    if ( file_exists( eZExtension::baseDirectory() . ‘/’ . $activeExtension . ‘/rss/’ . $activeExtension . ‘rssimport.php’ ) )
    {
        include_once( eZExtension::baseDirectory() . ‘/’ . $activeExtension . ‘/rss/’ . $activeExtension . ‘rssimport.php’ );
        $fieldDefinition = eZRSSImport::arrayMergeRecursive( $fieldDefinition, call_user_func( array(  $activeExtension . ‘rssimport’, ‘rssFieldDefinition’ ), array() ) );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il nous suffit donc de créer une classe dans &lt;code&gt;extension/monextension/rss/ezrssimage.php&lt;/code&gt; avec ce code, avec une methode du même nom: &lt;code&gt;rssFieldDefinition()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ezrssimagerssimport
{
    static function rssFieldDefinition()
    {
        return array( ‘item’ =&amp;gt; array( ‘elements’ =&amp;gt; array( ‘enclosure’ =&amp;gt; array( ‘attributes’ =&amp;gt; array( ‘url’ ) ) ) ) );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;et de déclarer cette classe dans le fichier &lt;code&gt;monextension/settings/site.ini.append.php&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[RSSSettings]
ActiveExtensions[]=ezrssimage
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voila pour ce tutoriel. Si je trouve le temps je packagerai cela dans une extension que je publierai sur &lt;strong&gt;GitHub&lt;/strong&gt; ou &lt;strong&gt;projects.ez.no&lt;/strong&gt; (sauf si quelqu&amp;rsquo;un me devance d’ici là).
N’hésitez pas à me signaler des erreurs ou améliorations que vous jugerez utiles.&lt;/p&gt;

&lt;p&gt;Vous pouvez retrouver les snippets PHP précédent ici &lt;a href=&#34;https://gist.github.com/killerwolf/5430167&#34;&gt;https://gist.github.com/killerwolf/5430167&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mon premier widget UWA netvibes / iGoogle</title>
      <link>/post/mon-premier-widget-uwa-netvibes-igoogle/</link>
      <pubDate>Sun, 18 Jan 2009 00:00:00 +0000</pubDate>
      
      <guid>/post/mon-premier-widget-uwa-netvibes-igoogle/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/images/post/netvibes.jpg&#34; alt=&#34;NetVibes iGoogle Widget&#34; title=&#34;NetVibes iGoogle Widget&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;A la base, le projet etait prévu pour mon tag:tag NabKiller, but i wanted to mess with the netvibes UWA. Ce widget affiche les horaires de diffusion des séries que je regarde régulièrement.&lt;/p&gt;

&lt;p&gt;Aimant beaucoup les mashups, je me suis pas amusé à lister toutes les séries qui existent. j’ai donc utilisé pour cela un services proposé par TVRage. Une fois votre compte créé sur TVRage et vos séries préférées ajoutées a votre compte, TVRage vous met à disposition un “Personalized RSS Feed” des séries difusées pendant la semaine en cours.&lt;/p&gt;

&lt;p&gt;Voici le mien:
&lt;a href=&#34;http://www.tvrage.com/myweekrss.php?tid=32948&amp;amp;hash=a60a8c06b3fd2afda135e2a42ab88a7e&#34;&gt;http://www.tvrage.com/myweekrss.php?tid=32948&amp;amp;hash=a60a8c06b3fd2afda135e2a42ab88a7e&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Comme vous pouvez le voir, le flux est très sale, on peut pas le manipuler aisément , les items sont hétérogènes. Donc ce fut assez laborieux pour agréger ce flux et lui donner l’apparence que j’ai voulu.&lt;/p&gt;

&lt;p&gt;Voulant allez le plus rapidement possible pour voir mon widget fonctionner, j’ai écrit une petite API en PHP5 qui agrège ce flux et ordonne correctement les données. Il est aussi possible de se servir du parser UWA/JS fourni par netvibes, et c’est une meilleur solution. car actuellement le widget est dépendant le l’api que j’ai écrite et qui est hostée sur un de mes sites, mais qu’importe, je compte pas diffuser mon widget pour le moment, la solution PHP me convient.&lt;/p&gt;

&lt;p&gt;Le widget prend 3 paramètres, le &lt;code&gt;tid&lt;/code&gt; et le &lt;code&gt;hash&lt;/code&gt; que vous trouvez dans l’url de votre flux personnalisé, et le troisiéme qui est l’adresse de mon API.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/post/netvibes-param.jpg&#34; alt=&#34;NetVibes iGoogle Widget&#34; title=&#34;NetVibes iGoogle Widget&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>